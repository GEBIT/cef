diff --git cc/trees/layer_tree_host.cc cc/trees/layer_tree_host.cc
index 7e0328a..9c255ae 100644
--- cc/trees/layer_tree_host.cc
+++ cc/trees/layer_tree_host.cc
@@ -625,6 +625,10 @@ void LayerTreeHost::ApplyPageScaleDeltaFromImplSide(
   SetPageScaleFromImplSide(page_scale);
 }
 
+void LayerTreeHost::SetSkipDrawing(bool skip_drawing) {
+  proxy_->SetSkipDrawing(skip_drawing);
+}
+
 void LayerTreeHost::SetVisible(bool visible) {
   if (visible_ == visible)
     return;
diff --git cc/trees/layer_tree_host.h cc/trees/layer_tree_host.h
index d98608d..b20052d 100644
--- cc/trees/layer_tree_host.h
+++ cc/trees/layer_tree_host.h
@@ -178,6 +178,9 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
 
   // Visibility and LayerTreeFrameSink -------------------------------
 
+  // Sets whether the render process should skip drawing results.
+  void SetSkipDrawing(bool skip_drawing);
+
   // Sets or gets if the LayerTreeHost is visible. When not visible it will:
   // - Not request a new LayerTreeFrameSink from the client.
   // - Stop submitting frames to the display compositor.
diff --git cc/trees/proxy.h cc/trees/proxy.h
index 70d28901b252..e0a129ebc45a 100644
--- cc/trees/proxy.h
+++ cc/trees/proxy.h
@@ -48,6 +48,8 @@ class CC_EXPORT Proxy {
 
   virtual void SetVisible(bool visible) = 0;
 
+  virtual void SetSkipDrawing(bool skip_drawing) = 0;
+
   virtual void SetNeedsAnimate() = 0;
   virtual void SetNeedsUpdateLayers() = 0;
   virtual void SetNeedsCommit() = 0;
diff --git cc/trees/proxy_main.cc cc/trees/proxy_main.cc
index 85bf14a0..59e434b 100644
--- cc/trees/proxy_main.cc
+++ cc/trees/proxy_main.cc
@@ -165,7 +165,7 @@ void ProxyMain::BeginMainFrame(
   // When we don't need to produce a CompositorFrame, there's also no need to
   // commit our updates. We still need to run layout and paint though, as it can
   // have side effects on page loading behavior.
-  bool skip_commit = begin_main_frame_state->begin_frame_args.animate_only;
+  bool skip_commit = skip_drawing_ | begin_main_frame_state->begin_frame_args.animate_only;
 
   // If main frame updates and commits are deferred, skip the entire pipeline.
   bool skip_full_pipeline = defer_main_frame_update_;
@@ -380,6 +380,13 @@ void ProxyMain::SetVisible(bool visible) {
                                 base::Unretained(proxy_impl_.get()), visible));
 }
 
+void ProxyMain::SetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("cc", "ProxyMain::SetSkipDrawing", "skip", skip_drawing);
+  skip_drawing_ = skip_drawing;
+  if (!skip_drawing)
+    SetNeedsCommit();
+}
+
 void ProxyMain::SetNeedsAnimate() {
   DCHECK(IsMainThread());
   if (SendCommitRequestToImplThreadIfNeeded(ANIMATE_PIPELINE_STAGE)) {
diff --git cc/trees/proxy_main.h cc/trees/proxy_main.h
index 7fbff9e..e7cc370 100644
--- cc/trees/proxy_main.h
+++ cc/trees/proxy_main.h
@@ -81,6 +81,7 @@ class CC_EXPORT ProxyMain : public Proxy {
   void SetLayerTreeFrameSink(
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void SetVisible(bool visible) override;
+  void SetSkipDrawing(bool skip_drawing) override;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
@@ -124,6 +125,8 @@ class CC_EXPORT ProxyMain : public Proxy {
 
   const int layer_tree_host_id_;
 
+  bool skip_drawing_ = false;
+
   // The furthest pipeline stage which has been requested for the next
   // commit.
   CommitPipelineStage max_requested_pipeline_stage_;
diff --git cc/trees/single_thread_proxy.cc cc/trees/single_thread_proxy.cc
index b15148d..c498435 100644
--- cc/trees/single_thread_proxy.cc
+++ cc/trees/single_thread_proxy.cc
@@ -116,6 +116,15 @@ void SingleThreadProxy::SetVisible(bool visible) {
     scheduler_on_impl_thread_->SetVisible(host_impl_->visible());
 }
 
+void SingleThreadProxy::SetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("cc", "SingleThreadProxy::SetSkipDrawing", "skip", skip_drawing);
+  DebugScopedSetImplThread impl(task_runner_provider_);
+
+  skip_drawing_ = skip_drawing;
+  if (!skip_drawing)
+    SetNeedsCommitOnImplThread();
+}
+
 void SingleThreadProxy::RequestNewLayerTreeFrameSink() {
   DCHECK(task_runner_provider_->IsMainThread());
   layer_tree_frame_sink_creation_callback_.Cancel();
@@ -593,7 +602,7 @@ bool SingleThreadProxy::SupportsImplScrolling() const {
 
 bool SingleThreadProxy::ShouldComposite() const {
   DCHECK(task_runner_provider_->IsImplThread());
-  return host_impl_->visible() && host_impl_->CanDraw();
+  return !skip_drawing_ && host_impl_->visible() && host_impl_->CanDraw();
 }
 
 void SingleThreadProxy::ScheduleRequestNewLayerTreeFrameSink() {
@@ -748,7 +757,7 @@ void SingleThreadProxy::BeginMainFrame(
   needs_impl_frame_ = false;
   animate_requested_ = false;
 
-  if (defer_main_frame_update_) {
+  if (skip_drawing_ | defer_main_frame_update_) {
     TRACE_EVENT_INSTANT0("cc", "EarlyOut_DeferBeginMainFrame",
                          TRACE_EVENT_SCOPE_THREAD);
     BeginMainFrameAbortedOnImplThread(
diff --git cc/trees/single_thread_proxy.h cc/trees/single_thread_proxy.h
index 565af3d..af4948e 100644
--- cc/trees/single_thread_proxy.h
+++ cc/trees/single_thread_proxy.h
@@ -44,6 +44,8 @@ class CC_EXPORT SingleThreadProxy : public Proxy,
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void ReleaseLayerTreeFrameSink() override;
   void SetVisible(bool visible) override;
+  void SetSkipDrawing(bool skip_drawing) override;
+  bool skip_drawing_ = false;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
diff --git content/browser/renderer_host/render_widget_host_impl.cc content/browser/renderer_host/render_widget_host_impl.cc
index 316e7cf..7c8b698 100644
--- content/browser/renderer_host/render_widget_host_impl.cc
+++ content/browser/renderer_host/render_widget_host_impl.cc
@@ -756,6 +756,14 @@ void RenderWidgetHostImpl::SetIsLoading(bool is_loading) {
     view_->SetIsLoading(is_loading);
 }
 
+void RenderWidgetHostImpl::SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) {
+  if (!skip_drawing) {
+    first_draw_after_skip_drawing_callback_ = std::move(callback);
+    is_first_draw_after_skip_drawing_ = true;
+  }
+  Send(new WidgetMsg_SetSkipDrawing(routing_id_, skip_drawing));
+}
+
 void RenderWidgetHostImpl::WasHidden() {
   if (is_hidden_)
     return;
@@ -1965,6 +1973,11 @@ void RenderWidgetHostImpl::OnFirstVisuallyNonEmptyPaint() {
 void RenderWidgetHostImpl::OnCommitAndDrawCompositorFrame() {
   if (owner_delegate_)
     owner_delegate_->RenderWidgetDidCommitAndDrawCompositorFrame();
+
+  if (is_first_draw_after_skip_drawing_ && !first_draw_after_skip_drawing_callback_.is_null()) {
+    is_first_draw_after_skip_drawing_ = false;
+    std::move(first_draw_after_skip_drawing_callback_).Run();
+  }
 }
 
 void RenderWidgetHostImpl::RendererExited() {
diff --git content/browser/renderer_host/render_widget_host_impl.h content/browser/renderer_host/render_widget_host_impl.h
index 4fd95dc..cbf9470 100644
--- content/browser/renderer_host/render_widget_host_impl.h
+++ content/browser/renderer_host/render_widget_host_impl.h
@@ -199,6 +199,9 @@ class CONTENT_EXPORT RenderWidgetHostImpl
   int GetRoutingID() override;
   RenderWidgetHostViewBase* GetView() override;
   bool IsCurrentlyUnresponsive() override;
+  void SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) override;
+  bool is_first_draw_after_skip_drawing_ = false;
+  base::OnceClosure first_draw_after_skip_drawing_callback_;
   bool SynchronizeVisualProperties() override;
   void AddKeyPressEventCallback(const KeyPressEventCallback& callback) override;
   void RemoveKeyPressEventCallback(
diff --git content/common/widget_messages.h content/common/widget_messages.h
index 208aea84126a..899eee0872e1 100644
--- content/common/widget_messages.h
+++ content/common/widget_messages.h
@@ -163,6 +163,9 @@ IPC_MESSAGE_ROUTED2(WidgetMsg_WasShown,
 // accordingly, etc.).
 IPC_MESSAGE_ROUTED1(WidgetMsg_SetActive, bool /* active */)
 
+// Sets whether the render process should skip drawing results.
+IPC_MESSAGE_ROUTED1(WidgetMsg_SetSkipDrawing, bool /* skip_drawing */)
+
 // Changes the text direction of the currently selected input field (if any).
 IPC_MESSAGE_ROUTED1(WidgetMsg_SetTextDirection,
                     blink::WebTextDirection /* direction */)
diff --git content/public/browser/render_widget_host.h content/public/browser/render_widget_host.h
index 4b98057..dff74a5 100644
--- content/public/browser/render_widget_host.h
+++ content/public/browser/render_widget_host.h
@@ -204,6 +204,9 @@ class CONTENT_EXPORT RenderWidgetHost : public IPC::Sender {
   // Returns true if the renderer is considered unresponsive.
   virtual bool IsCurrentlyUnresponsive() = 0;
 
+  // Sets whether the render process should skip drawing results on this widget.
+  virtual void SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) = 0;
+
   // Called to propagate updated visual properties to the renderer. Returns
   // whether the renderer has been informed of updated properties.
   virtual bool SynchronizeVisualProperties() = 0;
diff --git content/renderer/render_widget.cc content/renderer/render_widget.cc
index 5223ac9b8781..7f52f349b1cc 100644
--- content/renderer/render_widget.cc
+++ content/renderer/render_widget.cc
@@ -593,6 +593,7 @@ bool RenderWidget::OnMessageReceived(const IPC::Message& message) {
     IPC_MESSAGE_HANDLER(WidgetMsg_SetBounds_ACK, OnRequestSetBoundsAck)
     IPC_MESSAGE_HANDLER(WidgetMsg_UpdateScreenRects, OnUpdateScreenRects)
     IPC_MESSAGE_HANDLER(WidgetMsg_ForceRedraw, OnForceRedraw)
+    IPC_MESSAGE_HANDLER(WidgetMsg_SetSkipDrawing, OnSetSkipDrawing)
     IPC_MESSAGE_HANDLER(WidgetMsg_SetViewportIntersection,
                         OnSetViewportIntersection)
     IPC_MESSAGE_HANDLER(WidgetMsg_SetIsInert, OnSetIsInert)
@@ -614,6 +615,10 @@ bool RenderWidget::OnMessageReceived(const IPC::Message& message) {
   return handled;
 }
 
+void RenderWidget::OnSetSkipDrawing(bool skip_drawing) {
+  layer_tree_view_->layer_tree_host()->SetSkipDrawing(skip_drawing);
+}
+
 bool RenderWidget::Send(IPC::Message* message) {
   // Don't send any messages after the browser has told us to close, and filter
   // most outgoing messages when frozen.
diff --git content/renderer/render_widget.h content/renderer/render_widget.h
index 4e1534a98a96..5c691222f7c4 100644
--- content/renderer/render_widget.h
+++ content/renderer/render_widget.h
@@ -649,6 +649,7 @@ class CONTENT_EXPORT RenderWidget
   void OnUpdateVideoAck(int32_t video_id);
   void OnRequestSetBoundsAck();
   void OnForceRedraw(int snapshot_id);
+  void OnSetSkipDrawing(bool skip_drawing);
   void OnShowContextMenu(ui::MenuSourceType source_type,
                          const gfx::Point& location);
 
diff --git ui/compositor/compositor.h ui/compositor/compositor.h
index 313431f..0491487d 100644
--- ui/compositor/compositor.h
+++ ui/compositor/compositor.h
@@ -294,6 +311,9 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   // Sets the visibility of the underlying compositor.
   void SetVisible(bool visible);
 
+  // Sets whether the underlying compositor should skip drawing results.
+  void SetSkipDrawing(bool skip_drawing);
+
   // Gets the visibility of the underlying compositor.
   bool IsVisible();
 
diff --git ui/compositor/compositor.cc ui/compositor/compositor.cc
index 74e8d5b..21b763b 100644
--- ui/compositor/compositor.cc
+++ ui/compositor/compositor.cc
@@ -440,6 +440,10 @@ void Compositor::SetVisible(bool visible) {
     context_factory_private_->SetDisplayVisible(this, visible);
 }
 
+void Compositor::SetSkipDrawing(bool skip_drawing) {
+  host_->SetSkipDrawing(skip_drawing);
+}
+
 bool Compositor::IsVisible() {
   return host_->IsVisible();
 }
