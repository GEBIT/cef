diff --git cc/trees/layer_tree_host.cc cc/trees/layer_tree_host.cc
index 55391d950548..170c0589589e 100644
--- cc/trees/layer_tree_host.cc
+++ cc/trees/layer_tree_host.cc
@@ -662,6 +662,10 @@ void LayerTreeHost::ApplyPageScaleDeltaFromImplSide(float page_scale_delta) {
   SetPageScaleFromImplSide(page_scale);
 }
 
+void LayerTreeHost::SetSkipDrawing(bool skip_drawing) {
+  proxy_->SetSkipDrawing(skip_drawing);
+}
+
 void LayerTreeHost::SetVisible(bool visible) {
   if (visible_ == visible)
     return;
diff --git cc/trees/layer_tree_host.h cc/trees/layer_tree_host.h
index 64df3a33fc88..c67df3f83b0f 100644
--- cc/trees/layer_tree_host.h
+++ cc/trees/layer_tree_host.h
@@ -177,6 +177,9 @@ class CC_EXPORT LayerTreeHost : public MutatorHostClient {
 
   // Visibility and LayerTreeFrameSink -------------------------------
 
+  // Sets whether the render process should skip drawing results.
+  void SetSkipDrawing(bool skip_drawing);
+
   // Sets or gets if the LayerTreeHost is visible. When not visible it will:
   // - Not request a new LayerTreeFrameSink from the client.
   // - Stop submitting frames to the display compositor.
diff --git cc/trees/proxy.h cc/trees/proxy.h
index 0fe7a90fe3fb..23368524fb98 100644
--- cc/trees/proxy.h
+++ cc/trees/proxy.h
@@ -45,6 +45,8 @@ class CC_EXPORT Proxy {
 
   virtual void SetVisible(bool visible) = 0;
 
+  virtual void SetSkipDrawing(bool skip_drawing) = 0;
+
   virtual void SetNeedsAnimate() = 0;
   virtual void SetNeedsUpdateLayers() = 0;
   virtual void SetNeedsCommit() = 0;
diff --git cc/trees/proxy_main.cc cc/trees/proxy_main.cc
index f5b1875c8b07..a2eb16b2eb8d 100644
--- cc/trees/proxy_main.cc
+++ cc/trees/proxy_main.cc
@@ -169,7 +169,7 @@ void ProxyMain::BeginMainFrame(
   // When we don't need to produce a CompositorFrame, there's also no need to
   // commit our updates. We still need to run layout and paint though, as it can
   // have side effects on page loading behavior.
-  bool skip_commit = begin_main_frame_state->begin_frame_args.animate_only;
+  bool skip_commit = skip_drawing_ | begin_main_frame_state->begin_frame_args.animate_only;
 
   // If main frame updates and commits are deferred, skip the entire pipeline.
   bool skip_full_pipeline = defer_main_frame_update_;
@@ -386,6 +386,13 @@ void ProxyMain::SetVisible(bool visible) {
                                 base::Unretained(proxy_impl_.get()), visible));
 }
 
+void ProxyMain::SetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("cc", "ProxyMain::SetSkipDrawing", "skip", skip_drawing);
+  skip_drawing_ = skip_drawing;
+  if (!skip_drawing)
+    SetNeedsCommit();
+}
+
 void ProxyMain::SetNeedsAnimate() {
   DCHECK(IsMainThread());
   if (SendCommitRequestToImplThreadIfNeeded(ANIMATE_PIPELINE_STAGE)) {
diff --git cc/trees/proxy_main.h cc/trees/proxy_main.h
index cfef4ce60311..276c5ce015e6 100644
--- cc/trees/proxy_main.h
+++ cc/trees/proxy_main.h
@@ -76,6 +76,7 @@ class CC_EXPORT ProxyMain : public Proxy {
   void SetLayerTreeFrameSink(
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void SetVisible(bool visible) override;
+  void SetSkipDrawing(bool skip_drawing) override;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
@@ -120,6 +121,8 @@ class CC_EXPORT ProxyMain : public Proxy {
 
   const int layer_tree_host_id_;
 
+  bool skip_drawing_ = false;
+
   // The furthest pipeline stage which has been requested for the next
   // commit.
   CommitPipelineStage max_requested_pipeline_stage_;
diff --git cc/trees/single_thread_proxy.cc cc/trees/single_thread_proxy.cc
index 2a235b6dd900..3e100bf8f103 100644
--- cc/trees/single_thread_proxy.cc
+++ cc/trees/single_thread_proxy.cc
@@ -111,6 +111,15 @@ void SingleThreadProxy::SetVisible(bool visible) {
     scheduler_on_impl_thread_->SetVisible(host_impl_->visible());
 }
 
+void SingleThreadProxy::SetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("cc", "SingleThreadProxy::SetSkipDrawing", "skip", skip_drawing);
+  DebugScopedSetImplThread impl(task_runner_provider_);
+
+  skip_drawing_ = skip_drawing;
+  if (!skip_drawing)
+    SetNeedsCommitOnImplThread();
+}
+
 void SingleThreadProxy::RequestNewLayerTreeFrameSink() {
   DCHECK(task_runner_provider_->IsMainThread());
   layer_tree_frame_sink_creation_callback_.Cancel();
@@ -645,7 +654,7 @@ bool SingleThreadProxy::SupportsImplScrolling() const {
 
 bool SingleThreadProxy::ShouldComposite() const {
   DCHECK(task_runner_provider_->IsImplThread());
-  return host_impl_->visible() && host_impl_->CanDraw();
+  return !skip_drawing_ && host_impl_->visible() && host_impl_->CanDraw();
 }
 
 void SingleThreadProxy::ScheduleRequestNewLayerTreeFrameSink() {
@@ -802,7 +811,7 @@ void SingleThreadProxy::BeginMainFrame(
   needs_impl_frame_ = false;
   animate_requested_ = false;
 
-  if (defer_main_frame_update_) {
+  if (skip_drawing_ | defer_main_frame_update_) {
     TRACE_EVENT_INSTANT0("cc", "EarlyOut_DeferBeginMainFrame",
                          TRACE_EVENT_SCOPE_THREAD);
     BeginMainFrameAbortedOnImplThread(
diff --git cc/trees/single_thread_proxy.h cc/trees/single_thread_proxy.h
index 3cde647963d9..9d7d2f6f1bf0 100644
--- cc/trees/single_thread_proxy.h
+++ cc/trees/single_thread_proxy.h
@@ -46,6 +46,8 @@ class CC_EXPORT SingleThreadProxy : public Proxy,
       LayerTreeFrameSink* layer_tree_frame_sink) override;
   void ReleaseLayerTreeFrameSink() override;
   void SetVisible(bool visible) override;
+  void SetSkipDrawing(bool skip_drawing) override;
+  bool skip_drawing_ = false;
   void SetNeedsAnimate() override;
   void SetNeedsUpdateLayers() override;
   void SetNeedsCommit() override;
diff --git content/browser/renderer_host/render_widget_host_impl.cc content/browser/renderer_host/render_widget_host_impl.cc
index e2e3d649a002..be47bbdcd236 100644
--- content/browser/renderer_host/render_widget_host_impl.cc
+++ content/browser/renderer_host/render_widget_host_impl.cc
@@ -643,6 +643,15 @@ void RenderWidgetHostImpl::SetIsLoading(bool is_loading) {
     view_->SetIsLoading(is_loading);
 }
 
+void RenderWidgetHostImpl::SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) {
+  TRACE_EVENT1("renderer_host", "RenderWidgetHostImpl::SetSkipDrawing", "skip", skip_drawing);
+  if (!skip_drawing) {
+    first_draw_after_skip_drawing_callback_ = std::move(callback);
+    is_first_draw_after_skip_drawing_ = true;
+  }
+  Send(new WidgetMsg_SetSkipDrawing(routing_id_, skip_drawing));
+}
+
 void RenderWidgetHostImpl::WasHidden() {
   if (is_hidden_)
     return;
@@ -1825,6 +1834,13 @@ void RenderWidgetHostImpl::OnFrameSwapMessagesReceived(
     std::vector<IPC::Message> messages) {
   frame_token_message_queue_->OnFrameSwapMessagesReceived(frame_token,
                                                           std::move(messages));
+
+  // When receiving this message we know the viz compositor may have swapped the first rendered frame
+  // after a skip drawing phase, so we may have to run a callback.
+  if (is_first_draw_after_skip_drawing_ && !first_draw_after_skip_drawing_callback_.is_null()) {
+    is_first_draw_after_skip_drawing_ = false;
+    std::move(first_draw_after_skip_drawing_callback_).Run();
+  }
 }
 
 void RenderWidgetHostImpl::OnForceRedrawComplete(int snapshot_id) {
diff --git content/browser/renderer_host/render_widget_host_impl.h content/browser/renderer_host/render_widget_host_impl.h
index 15a23f954089..54eeaaf28562 100644
--- content/browser/renderer_host/render_widget_host_impl.h
+++ content/browser/renderer_host/render_widget_host_impl.h
@@ -228,6 +228,9 @@ class CONTENT_EXPORT RenderWidgetHostImpl
   int GetRoutingID() override;
   RenderWidgetHostViewBase* GetView() override;
   bool IsCurrentlyUnresponsive() override;
+  void SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) override;
+  bool is_first_draw_after_skip_drawing_ = false;
+  base::OnceClosure first_draw_after_skip_drawing_callback_;
   bool SynchronizeVisualProperties() override;
   void AddKeyPressEventCallback(const KeyPressEventCallback& callback) override;
   void RemoveKeyPressEventCallback(
diff --git content/common/widget_messages.h content/common/widget_messages.h
index dbd1115f1eb9..86253a47fae2 100644
--- content/common/widget_messages.h
+++ content/common/widget_messages.h
@@ -135,6 +135,9 @@ IPC_MESSAGE_ROUTED3(
 // accordingly, etc.).
 IPC_MESSAGE_ROUTED1(WidgetMsg_SetActive, bool /* active */)
 
+// Sets whether the render process should skip drawing results.
+IPC_MESSAGE_ROUTED1(WidgetMsg_SetSkipDrawing, bool /* skip_drawing */)
+
 // Changes the text direction of the currently selected input field (if any).
 IPC_MESSAGE_ROUTED1(WidgetMsg_SetTextDirection,
                     blink::WebTextDirection /* direction */)
diff --git content/public/browser/render_widget_host.h content/public/browser/render_widget_host.h
index ceaeff19d871..9999d2515e61 100644
--- content/public/browser/render_widget_host.h
+++ content/public/browser/render_widget_host.h
@@ -212,6 +212,9 @@ class CONTENT_EXPORT RenderWidgetHost : public IPC::Sender {
   // Returns true if the renderer is considered unresponsive.
   virtual bool IsCurrentlyUnresponsive() = 0;
 
+  // Sets whether the render process should skip drawing results on this widget.
+  virtual void SetSkipDrawing(bool skip_drawing, base::OnceClosure callback) = 0;
+
   // Called to propagate updated visual properties to the renderer. Returns
   // whether the renderer has been informed of updated properties.
   virtual bool SynchronizeVisualProperties() = 0;
diff --git content/renderer/render_widget.cc content/renderer/render_widget.cc
index db473d9f1558..365a72a37cef 100644
--- content/renderer/render_widget.cc
+++ content/renderer/render_widget.cc
@@ -645,6 +645,7 @@ bool RenderWidget::OnMessageReceived(const IPC::Message& message) {
     IPC_MESSAGE_HANDLER(WidgetMsg_SetBounds_ACK, OnRequestSetBoundsAck)
     IPC_MESSAGE_HANDLER(WidgetMsg_UpdateScreenRects, OnUpdateScreenRects)
     IPC_MESSAGE_HANDLER(WidgetMsg_ForceRedraw, OnForceRedraw)
+    IPC_MESSAGE_HANDLER(WidgetMsg_SetSkipDrawing, OnSetSkipDrawing)
     IPC_MESSAGE_HANDLER(WidgetMsg_SetViewportIntersection,
                         OnSetViewportIntersection)
     IPC_MESSAGE_HANDLER(WidgetMsg_SetIsInert, OnSetIsInert)
@@ -666,6 +667,11 @@ bool RenderWidget::OnMessageReceived(const IPC::Message& message) {
   return handled;
 }
 
+void RenderWidget::OnSetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("renderer", "RenderWidget::OnSetSkipDrawing", "skip", skip_drawing);
+  layer_tree_view_->layer_tree_host()->SetSkipDrawing(skip_drawing);
+}
+
 bool RenderWidget::Send(IPC::Message* message) {
   // Undead RenderWidgets should not be used.
   CHECK(!is_undead_);
diff --git content/renderer/render_widget.h content/renderer/render_widget.h
index b1e5e8a44ad9..6ff4c96f801b 100644
--- content/renderer/render_widget.h
+++ content/renderer/render_widget.h
@@ -770,6 +770,7 @@ class CONTENT_EXPORT RenderWidget
   void OnUpdateVideoAck(int32_t video_id);
   void OnRequestSetBoundsAck();
   void OnForceRedraw(int snapshot_id);
+  void OnSetSkipDrawing(bool skip_drawing);
   void OnShowContextMenu(ui::MenuSourceType source_type,
                          const gfx::Point& location);
 
diff --git ui/compositor/compositor.cc ui/compositor/compositor.cc
index c18e597d76c5..1872c9c1daf6 100644
--- ui/compositor/compositor.cc
+++ ui/compositor/compositor.cc
@@ -471,6 +471,11 @@ void Compositor::SetVisible(bool visible) {
     context_factory_private_->SetDisplayVisible(this, visible);
 }
 
+void Compositor::SetSkipDrawing(bool skip_drawing) {
+  TRACE_EVENT1("cc", "Compositor::SetSkipDrawing", "skip", skip_drawing);
+  host_->SetSkipDrawing(skip_drawing);
+}
+
 bool Compositor::IsVisible() {
   return host_->IsVisible();
 }
diff --git ui/compositor/compositor.h ui/compositor/compositor.h
index 5410ee7a65ab..94252a82cbd3 100644
--- ui/compositor/compositor.h
+++ ui/compositor/compositor.h
@@ -305,6 +305,9 @@ class COMPOSITOR_EXPORT Compositor : public cc::LayerTreeHostClient,
   // Sets the visibility of the underlying compositor.
   void SetVisible(bool visible);
 
+  // Sets whether the underlying compositor should skip drawing results.
+  void SetSkipDrawing(bool skip_drawing);
+
   // Gets the visibility of the underlying compositor.
   bool IsVisible();
 
